#!/usr/bin/ruby

keywords = %w(nusdas path filename creator type1 type2 type3 member
	memberlist basetime validtime validtime1 validtime2
	plane plane1 plane2
	element elementmap size basepoint distance standard others
	value packing missing information subcntl forcedrlen options)
spellfix = {
	'misssing' => 'missing',
	'other' => 'others',
	'subctnl' => 'subcntl',
	'option' => 'options'
}

class Hash
	def prepare(key)
		return if self[key]
		self[key] = []
	end
end

sym8 = Hash.new
sym4 = Hash.new

header = File.open("sys_kwd.h", "w")
for word in keywords
	up = word.upcase[0..7]
	up4 = word.upcase[0..3]
	upword = word.upcase
	sym8.prepare(up)
	sym8[up].push [upword, upword]
	sym4.prepare(up4)
	sym4[up4].push [upword, upword]
end
for bad, good in spellfix
	up = bad.upcase[0..7]
	up4 = bad.upcase[0..3]
	upword = bad.upcase
	upword2 = good.upcase
	sym8.prepare(up)
	sym8[up].push [upword, upword2]
	sym4.prepare(up4)
	sym4[up4].push [upword, upword2]
end

symfile = File.open("def_phase.smb", "w")
for key in sym8.keys.sort
	symfile.puts key
end
symfile.close

defhdr = File.open("def_phase.h", "w")
defhdr.print <<EOF
/** @file
 * @brief [auto-generated by def_phase.rb] token2phase() used in def_read.c.
 *
 * Do not edit this file.
 */

/** phase id corresponding to given keyword */
	INLINE enum parse_phase
token2phase(const char *token)
{
#if ALLOW_LONG_LONG_SWITCH
	sym8_t		sym;
	sym = str2sym8(token);
#else
	sym4_t		sym;
	sym = str2sym4(token);
#endif
	switch (sym) {
#if ALLOW_LONG_LONG_SWITCH
EOF

for up in sym8.keys.sort
	list = sym8[up]
	if list.size == 1 and list.first.first.size < 8
		defhdr.print <<EOF
	case SYM8_#{up}:
		return p#{list.first.last};
EOF
		next
	end
	if list.size == 1 and list.first.first.size == 8
		defhdr.print <<EOF
	case SYM8_#{up}:
		return (token[8] == '\\0') ? p#{list.first.last} : pERR;
EOF
		next
	end
	bad, good = list.shift
	defhdr.print <<EOF
	case SYM8_#{up}:
		if (strcmp(token, \"#{bad}\") == 0) {
			return p#{good};
EOF
	for bad, good in list
	defhdr.print <<EOF
		} else if (strcmp(token, \"#{bad}\") == 0) {
			return p#{good};
EOF
	end
	defhdr.print <<EOF
		} else {
			return pERR;
		}
EOF
end

defhdr.print <<EOF
#else
EOF

for up in sym4.keys.sort
	list = sym4[up]
	if list.size == 1 and list.first.first.size < 4
		defhdr.print <<EOF
	case SYM4_#{up}:
		return p#{list.first.last};
EOF
		next
	end
	if list.size == 1 and list.first.first.size == 4
		defhdr.print <<EOF
	case SYM4_#{up}:
		return (token[4] == '\\0') ? p#{list.first.last} : pERR;
EOF
		next
	end
	bad, good = list.shift
	defhdr.print <<EOF
	case SYM4_#{up}:
		if (strcmp(token, \"#{bad}\") == 0) {
			return p#{good};
EOF
	for bad, good in list
	defhdr.print <<EOF
		} else if (strcmp(token, \"#{bad}\") == 0) {
			return p#{good};
EOF
	end
	defhdr.print <<EOF
		} else {
			return pERR;
		}
EOF
end

defhdr.print <<EOF
#endif
	}
	return pERR;
}
EOF
defhdr.close
