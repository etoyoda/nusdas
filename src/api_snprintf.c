/** @file
 * @brief 関数 nusdas_snprintf() の実装
 */

#include "config.h"
#include "nusdas.h"
#include <stddef.h>
#include <stdarg.h>
# define NEED_VSNPRINTF
#include "sys_err.h"

/** @brief 固定バイト数対応 snprintf()
 *
 * 書式 @p fmt に従いそれ以降の引数を文字列化し、
 * 長さ @p bufsize の配列 @p buf に格納する。
 * printf(3) と同様、変換指定は `%' 文字、フラグ (オプション)、
 * 数字列 (1--9) による印字幅 (オプション)、
 * ピリオド (`.') を前置した数字列による精度 (オプション)、
 * 型指定 (オプション)、
 * 変換指定文字からなる。
 * 変換指定以外の @p fmt 内の文字はそのまま転写される。
 *
 * @retval 正 実際に書き込まれた文字数 (ヌル終端を含まない)
 * @retval -1 エラー
 *
 * <H3>フラグ</H3>
 * <DL>
 * <DT>0 (ゼロ)<DD>数値変換
 * (`a', `d', `b', `x', `X', `u', `o') の結果が
 * 印字幅に満たない場合、左側にゼロを埋める。
 * <DT>$-$<DD>変換後の文字列を印字幅内で左寄せする。
 * <DT>+<DD>変換指定 `d' または `a' について、
 * 数値が正のとき `+' 記号を省略しない。
 * <DT>#<DD>代替的書式を使用する。
 * </DL>
 *
 * <H3>印字幅</H3>
 * <UL>
 * <LI>印字幅は、変換の結果埋め込まれる文字が占める最小の字数を指定する。
 * <LI>変換結果が印字幅に満たない場合、左側にスペースが補われる
 * (前項フラグによって挙動を変えられる)。
 * <LI>変換結果が印字幅を超える場合、そのまま用いられる。
 * つまり、充分な印字幅を与えないと書式が崩れることがある。
 * <LI>型指定 `y', `m' または変換指定 `%', `c' では印字幅は効果をもたない。
 * </UL>
 *
 * <H3>精度</H3>
 * <UL>
 * <LI>浮動小数点数変換 (`a') については、精度が小数部の占める桁数となる。
 * <LI>浮動小数点数変換 (`g') については、精度が仮数部の占める桁数となる。
 * <LI>文字列変換 (`s') については、変換で埋め込まれる文字は最大で
 * (精度) 個である。
 * Fortran から渡されたデータのようにヌル終端されていない
 * 固定長文字列の印字に用いられるが、
 * ヌル文字があればそこで止まってしまう (例外あり後述)。
 * <LI>その他の変換指定においては精度は効果をもたない。
 * </UL>
 *
 * <H3>型指定</H3>
 * 適用可能な変換指定に付いては個々の変換指定を見よ。
 * <DL>
 * <DT>l (小文字のエル)<DD>引数は long 型または unsigned long 型である。
 * <DT>z<DD>引数は size_t 型である (C99 準拠)。
 * <DT>P<DD>引数は N_SI4 型または N_UI4 型である。
 * <DT>Q<DD>引数は N_SI8 型または N_UI8 型である。
 * これらの型が構造体として実装されている環境でも、
 * アプリケーションプログラムは構造体へのポインタではなく構造体そのものを
 * 引数に渡すこと。
 * <DT>y<DD>引数は struct nustype_t (ライブラリ内部の非公開構造型)
 * へのポインタである。`s' 変換指定にだけ使用できて、
 * 結局のところ <TT>%ys</TT> はあたかも <TT>%Qs%Ps%Ps</TT> であるかのように
 * 種別1, 種別2, 種別3 を連結して印字する。
 * また <TT>%#ys</TT> はあたかも <TT>%Qs.%Ps.%Ps</TT> であるかのように
 * ピリオド区切りで印字する (パンドラ準拠)。
 * このとき印字幅と精度は効果をもたない。
 * <DT>m<DD>引数は struct nusdims_t (ライブラリ内部の非公開構造型)
 * へのポインタである。`s' 変換指定にだけ使用できて、
 * 結局のところ <TT>%ms</TT> はあたかも
 * <TT>%12PT/%4.4s/%12PT/%6.6s/%6.6s</TT> であるかのように
 * スラッシュ区切りで基準時刻、メンバ名、対象時刻1, 面1, 要素名を印字する。
 * メンバ名がすべてスペースのときは ``<TT>none</TT>'' に置換される。
 * また <TT>%#ms</TT> はあたかも
 * <TT>%#15PT/%4.4s/%#15PT/%Ps/%Ps</TT> であるかのように
 * 時間に区切り文字を入れるとともに空白を詰める (パンドラ準拠)。
 * このとき印字幅と精度は効果をもたない。
 * </DL>
 *
 * <H3>変換指定</H3>
 * <DL>
 * <DT>%<DD>パーセント記号 `<TT>%</TT>' そのものを印字する。引数は使わない。
 * <DT>d<DD>
 * 符号付き整数型引数を十進表記する。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は int とみなされる。
 * <DT>b<DD>
 * 符号無し整数型引数を二進表記する。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は unsigned とみなされる。
 * <DT>x<DD>
 * 符号無し整数型引数を十六進表記する (英字は小文字を用いる)。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は unsigned とみなされる。
 * <DT>X<DD>
 * 符号無し整数型引数を十六進表記する (英字は大文字を用いる)。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は unsigned とみなされる。
 * <DT>u<DD>
 * 符号無し整数型引数を十進表記する。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は unsigned とみなされる。
 * <DT>o<DD>
 * 符号無し整数型引数を八進表記する。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * さもなくば引数は unsigned とみなされる。
 * <DT>p<DD>
 * ポインタを整数にキャストしたものを十六進表記する。
 * AIX の 64 ビットモードではシステムの printf(3) が不当にも
 * 下位 32 ビットのみを表示するのに対して
 * 本関数は正しく 64 ビットを表示できる。
 * <DT>T<DD>
 * 符号付き整数型引数を数値予報通算分とみなして印字する。
 * `#' フラグを指定すると年月日をハイフン (`<TT>-</TT>') で区切り、
 * 日と時の間に `<TT>t</TT>' 文字を挿入する (パンドラ準拠)。
 * 型指定は `Q', `P', `l', `z' を認識する。
 * `Q' を指定すると
 * あたかも <TT>%PT/%PT</TT> であるかのように
 * 上位・下位 32 ビットの数値を 2 つの時刻として印字する。
 * <DT>a<DD>
 * 浮動小数点数を十六進指数表記する (C99 準拠)。
 * 計算機の浮動小数点形式にかかわらず IEEE 形式による。
 * <DT>g<DD>
 * 浮動小数点数を十進指数表記する。
 * 指数部が -4 から (精度 - 1) のときは固定小数点表記となる。
 * 省略時は精度 6 である。
 * いずれにしても仮数部末尾のゼロは印字されず、小数部がゼロなら
 * 小数点も印字されない。
 * <DT>c<DD>
 * 引数を unsigned 整数値とみなしてその文字コードをもつ文字を印字する。
 * 印字幅は効果をもたない。
 * <DT>s<DD>
 * 引数を文字列として評価して印字する。
 * 型指定がない場合は引数はヌル終端の char * とみなされる。
 * 型指定が `Q' または `P' のときは
 * 整数値を表わす 8 バイトまたは 4 バイトのバイト列を
 * 文字列としてそのまま (バイトオーダー変換等せずに) 解釈したものである。
 * このときヌル文字は終端ではなく、
 * 末尾に任意個のスペースがある場合は
 * あたかも文字列終端であるかのように扱われる。
 * 型指定 `y' と `m' については前項参照。
 * </DL>
 *
 * <H3>注意</H3>
 * <UL>
 * <LI>配列長 @p bufsize が不足する場合エラーとなる。
 * これによってバッファオーバーフローを安全に避けることができる。
 * <LI>標準関数 sprintf(3) の書式の一部はサポートされていない。
 * <LI>文字列 (s) 変換指定で ASCII 図形文字以外のバイナリを
 * 印字しようとすると
 * <TT>\BACKSLASH 0</TT>,
 * <TT>\BACKSLASH t</TT>,
 * <TT>\BACKSLASH n</TT>,
 * <TT>\BACKSLASH r</TT> あるいは
 * <TT>\BACKSLASH 377</TT> のような八進表記で印字される。
 * ために <TT>%.8s</TT> のように精度を指定すると 8 バイトすべて
 * 印字されないことがある。
 * <LI>バグ: ゼロフラグは数値の変換結果に符号が付く場合に対応していない
 * (NuSDaS 内部では使っていない)。
 * </UL>
 * <H3>履歴</H3>
 * この関数は NuSDaS 1.3 で導入された。
 */
int NuSDaS_snprintf(char *buf, /**< 結果格納配列 */
		unsigned bufsize, /**< 結果配列サイズ */
		const char *fmt, /**< 書式 */
		... /**< 印字すべき値 */)
{
    va_list ap;
    int len;
    va_start(ap, fmt);
    len = nus_vsnprintf(buf, bufsize, fmt, ap);
    va_end(ap);
    return len;
}
