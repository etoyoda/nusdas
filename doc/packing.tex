\chapter{パッキング}
\label{chap:packing}
\section{一般論}

パッキング (packing) とは、数値データを圧縮保存する技法のひとつで、
線形変換によってデータをビット数の少ない別の型
(たいていは整数) に近似的に変換することによって使用ビット数を減らすものです。
以下の {\tt 1PAC}, {\tt 2PAC}, {\tt 2UPC}, {\tt 4PAC}
がその (本来の) パッキングにあたります (数字がバイト数を表します)。
この圧縮は不可逆で、
データを {\tt nusdas\_write} してから {\tt nusdas\_read} しても
元のデータとは一致しません。

NuSDaS ではパッキングという言葉が少々拡大解釈されていて、
定義ファイルの PACKING 文 \SectionRef{sec:def:PACKING} などによって
パッキングだけでなく、
ランレングス圧縮 {\tt RLEN} などの圧縮 (compression) や
数値型をそのまま保存する方式が選択できるようになっています。


\section{1PAC}

8ビット (1バイト) 符号なし整数で保存するパッキングです。

エンコード (データ列 $y_i$ からファイルに書くべき整数列 $n_i$ を求めるとき)
には次のようにします:
\begin{eqnarray}
b &:=& \min_i(y_i) \\
a &:=& \frac{\max_i(y_i) - \min_i(y_i)}{252} \\
n_i &:=& {\rm floor}\left[\frac{y_i - b}{a} + 0.5\right]
\end{eqnarray}
ここで、${\rm floor}[x]$ は小数部切り捨てです。
式から明らかですが $0 \le n_i \le 252$ となりますので
8 ビット符号なし整数で表現できるわけです。
データ列がすべて同じ値の場合は、$a=1, n_i = 0$ とされます。
ちなみに $a$ の名前は amplitude (振幅), $b$ の名前は
base (ここでは最小値のつもりの和製英語) からきています。

デコード (ファイルから読んだ $a, b, n_i$ からデータを復元するとき) は
\begin{equation}
y_i' := a n_i + b
\end{equation}
として、もとのデータに近い浮動小数点数 $y_i'$ を復元します。

{\tt 1PAC} の読み書きは、
ユーザー配列の型が{\tt I2}, {\tt I4}, {\tt R4}, {\tt R8} でなければなりません。

\section{2PAC}

16ビット (2バイト) {\bf 符号付き}整数で保存するパッキングです。
{\bf これを使ってはいけません。}

エンコードは次のようになっています:
\begin{eqnarray}
b &:=& \frac{\max_i(y_i) + \min_i(y_i)}{2} \\
a &:=& \frac{\max\left[\max_i(y_i) - b, b - \min_i(y_i)\right]}{32765} \\
n_i &:=& {\rm floor}\left[\frac{y_i - b}{a} + 0.5\right]
\end{eqnarray}
デコードの方法は 1PAC と同じです。
かつて $a$ の決め方が悪く $n_i > 32767$ となって
とんでもない値がデコードされるバグがあったのは修正されています。
しかし最小値が再現しないため、積算降水量の差をとると負の降水量が生じる、
といった問題は本質的に解消不能なため、
NAPS8 以降の数値予報ルーチンでは 2PAC の使用は禁止されています。

{\tt 2PAC} の読み書きは、
ユーザー配列の型が{\tt I4}, {\tt R4}, {\tt R8} でなければなりません。

\section{2UPC}
16ビット (2バイト) 符号なし整数で保存するパッキングです。

エンコードは次のようです:
\begin{eqnarray}
b &:=& \min_i(y_i) \\
a &:=& \frac{\max_i(y_i) - \min_i(y_i)}{65532} \\
n_i &:=& {\rm floor}\left[\frac{y_i - b}{a} + 0.5\right]
\end{eqnarray}

{\tt 2UPC} の読み書きは、
ユーザー配列の型が{\tt I4}, {\tt R4}, {\tt R8} でなければなりません。

\section{4PAC}

32ビット (4バイト) 符号つき整数で保存するパッキングです。
あまり使われません。

エンコードは次のようです:
\begin{eqnarray}
b &:=& \frac{\max_i(y_i) + \min_i(y_i)}{2} \\
a &:=& \frac{\max\left[\max_i(y_i) - b, b - \min_i(y_i)\right]}{2147483645} \\
n_i &:=& {\rm floor}\left[\frac{y_i - b}{a} + 0.5\right] \label{eq:2upc:n}
\end{eqnarray}

{\tt 4PAC} の読み書きは、
ユーザー配列の型が{\tt R4} または {\tt R8} でなければなりません。

\section{N1I2}

10倍した値を符号付き2バイト整数に変換してファイルに格納する。

ユーザー配列の型は{\tt R4}, {\tt I2}, {\tt I4} に限られる。

このPACK型の場合は、ユーザー配列の型によって以下のように挙動が異なるので
注意が必要である。
\subsection{ユーザー配列型がR4の場合}
エンコードの際には、ユーザー配列の値を10倍した値を符号付き2バイト整数に
キャストした値をファイルに格納する。
デコードの際には、符号付き2バイト整数 を 10 で除した値を浮動小数点数にキャ
ストしてユーザー配列に格納する。

すなわち、ユーザー配列の値は実際の値でよい。

\subsection{ユーザー配列型がI2, I4の場合}
エンコードの際には、ユーザー配列そのままの値を符号付き2バイト整数にキャスト
した値をファイルに格納する。
デコードの際には、符号付き2バイト整数を符号付き2バイト整数、または符号付
き4バイト整数にキャストしてユーザー配列に格納する。

ユーザー側で、
エンコードの際には10倍を、デコードの際には0.1倍をする必要があるので注意。

\section{RLEN}
非負のデータを圧縮するための
ランレングス符号化法である。1次元に連続したデータがある場合、その値と同
じ値のデータの継続する長さ(ランレングス)を1つのセットとし、セットをつな
げることで1次元に連続したデータを表現する手法である。

圧縮データの中で一つの格子点値が占めるビット数を変えることで、様々な範囲
の(非負の)整数データを圧縮できるが、
 NuSDaS では 8ビットのみをサポートしている。

ユーザー配列の型は
{\tt I1}, {\tt I2}, {\tt I4}, {\tt R4}, {\tt R8}が使えるが、エンコードで
きるデータは符号なし1バイト整数で表現できる範囲である%
\footnote{
厳密には、符号なし1バイト整数の最大値である255を含むデータは圧縮できない。
データの最大値{\tt MAXV}を超えたデータは、値 -- {\tt MAXV}を
その直前の値のランレングスとするが、{\tt MAXV}が255ではランレングスを
表現できないからである。254 ではランレングスとして1だけを表現できるが、
ランレングスが1の場合は圧縮の意味がない。
}。

ランレングスのデータは、ビット数{\tt NBIT}、データの最大値{\tt MAXV}、
データ列から構成される。

データ列を符号なしで{\tt NBIT}ずつ区切って読んだとき、
{\tt MAXV}以下の値は格子点の値とする。{\tt MAXV} を超える値は、ランレン
グスを表すものとする。1セットは、まず値を配置し、もしその値が連続するよ
うであれば後ろにランレングスを付加することによって作られる。{\tt MAXV}
より大きなデータが続く場合はすべてそのセットのランレングスの情報であり、
{\tt MAXV} 以下のデータが現れた時点でそのセットは終了し、この{\tt MAXV}
以下のデータは次のセットの値になる。また、同じ値が連続しない場合は
ランレングスは付加されず、次のセットに移る。

ランレングスは $L = 2^{\tt NBIT} - 1 - {\tt MAXV}$ としたとき、$L$進数に
よって表現している。{\tt MAXV} を超える値が$N$個続いた場合、その値を
$a_n(n = 1, 2, \cdots, N)$(インデックスは出現順)とすると
ランレングス$R$は
\begin{equation}
R=\sum_{n = 1}^{N}\left[L^{(n-1)}\{a_n- ({\tt MAXV + 1})\}\right] + 1
\end{equation}
と求めることができる。

\section{I1}
ユーザー配列を符号なし1バイト整数型にキャストして格納する。

\section{I2}
ユーザー配列を符号つき2バイト整数型にキャストして格納する。

\section{I4}
ユーザー配列を符号つき4バイト整数型にキャストして格納する。

\section{R4}
ユーザー配列を単精度浮動小数点型にキャストして格納する。

\section{R8}
ユーザー配列を倍精度浮動小数点型にキャストして格納する。

\section{2UPJ}

{\tt 2UPC} と同様にデータを 16 ビット符号なし整数で表現した後、
整数列を JPEG2000 圧縮したものをファイルに格納する。
レポジトリでは 2009-11-04 に追加された機能。

{\tt 2UPJ} の読み書きは、ユーザー配列の型が {\tt I4},
{\tt R4}, {\tt R8} に限られる
({\tt N\_NC} によるレコード内容直接読み取りは 2010-04-21 に追加された)。

\section{2UPP}

{\tt 2UPC} と同様にデータを 16 ビット符号なし整数で表現した後、整数列を
複合差分圧縮 (GRIB2 DRT5.3 に類似) したものをファイルに格納する。
まず、{\tt 2UPC}の式\ref{eq:2upc:n}で得られたバイト列$n_k$に対して以下の$p_k$を作成する。
\begin{equation}
  p_k = \left\{ \begin{array}{ll}
    \mathrm{mod}\left(n_k + 32768, \, 
      65536\right) & (k = 0, 1) \,, \\
    \mathrm{mod}\left(n_{k} - 2n_{k-1} + n_{k-2} + 32768, \,
      65536\right) & (k \geq 2) \,,
  \end{array} \right.
\end{equation}

NuSDaSの複合差分圧縮では$p_k$を32格子単位の群ごとに保存する。
格子数$N$のときの群数は
\begin{equation}
N_G = (N - 1) / 32 + 1,
\end{equation}
で得られる\footnote{$N=0$のとき$N_G=1$となるので注意}。
ただし最後の群に所属する格子の数は32未満になる可能性がある。
$p_k$を群$i$の$j$番目のデータとして
\begin{equation}
P_{ij} \equiv p_k \quad \left(i=k/32,\,j=\mathrm{mod}\left(k,32\right) \right),
\end{equation}
と割り当てた後、以下の処理を行う。
\begin{eqnarray}
R_i &=& \min_j \left(P_{ij}\right) \,, \\
D_{ij} &=& P_{ij} - R_i \,, \\
W_i &=& \mathrm{bits}\left(\max_j\left(D_{ij}\right)\right) - 1 \,.
\end{eqnarray}

$\mathrm{bits}(m)$は整数$m$のbit幅を求める関数で例えば
$\mathrm{bits}(5) = 3$となる。ただし
$\mathrm{bits}(0) \equiv 1$として扱う。$R_i$の取りうる値は
$0$から$65535$、$W_i$は$0$から$15$の値をとりうる。
また$D_{ij}$のすべての値は必ず$(W_i+1)$bit幅で表現できる。
このようにして求めた$R_i$, $W_i$をそれぞれ2バイト幅、4bit幅で
\ref{table.fmt.data.2upp}に格納する。複合差分圧縮されたデータ本体$D_{ij}$は
\ref{table.fmt.data.2upp}の圧縮データの位置に$(W_i + 1)$bit幅で格納する

{\tt 2UPP} の読み書きは、ユーザー配列の型が {\tt I4},
{\tt R4}, {\tt R8} に限られる。
